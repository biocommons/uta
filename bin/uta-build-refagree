#!/usr/bin/env python

from __future__ import division, print_function, unicode_literals

__doc__ = """generates data for agreement/discordance between refseq
transcripts and reference genome"""
__version__ = '0.0.0'

import logging, os, pprint, sys, time
import psycopg2, psycopg2.extras
import locus.tools.refagree as ltr

import IPython

############################################################################

def strand_sign(strand_val):
    if strand_val is None: return None
    if strand_val == 1: return '+'
    if strand_val == -1: return '-'
    raise Exception('invalid strand value (expected None, +1, or -1)')

def header(src=None):
    return """# transcript-genome agreement
# run on: {ts}
# accession source: {src}
# Records consist of a summary line followed by 0 or more mismatch lines:
#
# * <ac> \\t <locus> \\t <strand><maploc> \\t <#exons> \\t <n_ex_eq?> \\t <ex_len_eq?> \\t <n_mismatches> \\t <mismatch_summary>
# \\t <chr> \\t <gstart> \\t <gend> \\t <hgvsc_pos> \\t <exon#> \\t <exon_start> \\t <exon_end> \\t <type> \\t <g_allele> \\t <t_allele> \\t <seqviewer_url>
#
# \\t == tab
# Lines starting with # are comments. Empty lines are ignored.
# All coordinates and indexes are human (1-based, inclusive).
# Mismatch key (a la cigar): X=sub, I=ins, D=del
# This would have been XML if humans weren't involved. Darn humans. 
""".format(src=src,ts=time.strftime('%F %TZ',time.gmtime()))


## EXAMPLE:
## * NM_000022.2   ADA -20q13.12   12  True    True    1   1X/0I/0D
##     20  43264927    43264927    NM_000022.2:c.36    3   60  60  X   C   T   http://1.usa.gov/KXlHan
## * NM_000035.3   ALDOB   -9q21.3-q22.2   9   True    True    0   0X/0I/0D


def fetch_acvs(cur):
    cur = conn.cursor()
    cur.execute('select ac from transcripts.transcript')
    return [ e[0] for e in cur ]

def fetch_gene_info_for_transcript(cur,acv):
    sql = """
select distinct G.chr,G.strand,G.start_i,G.end_i,G.gene,G.maploc,G.descr,G.summary
from gene G
join transcript T on G.gene=T.gene
where T.ac = %(acv)s
"""
    cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
    cur.execute(sql, {'acv': acv})
    assert cur.rowcount == 1, 'fetched %d genes for %s' % (cur.rowcount,acv)
    return dict(cur.fetchone())

def fetch_transcript_info(cur,acv):
    cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
    sql = """
SELECT ac, chr, cds_start_i, cds_end_i, exists (select * from transcript_exon TE join gtx_alignment GA on TE.transcript_exon_id=GA.transcript_exon_id and GA.cigar~'[XDI]' where TE.ac=T.ac) as mismatches_p, seq
FROM transcripts.transcript T
JOIN gene G on T.gene=G.gene
WHERE T.ac=%(acv)s
"""
    cur.execute( sql, {'acv': acv} )
    assert cur.rowcount <= 1, 'fetched %d transripts for %s' % (cur.rowcount,acv)
    return dict(cur.fetchone()) if cur.rowcount == 1 else None

def fetch_transcript_exon_coords(conn,acv):
    cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
    sql = """SELECT E.start_i,E.end_i FROM transcript_exon E WHERE E.ac=%(acv)s ORDER BY start_i;"""
    cur.execute( sql, {'acv': acv} )
    return cur.fetchall()

def fetch_genome_exon_coords(conn,acv,assy=None):
    """return genome interbase coordinates of exons in transcript order; start<end regardless of strand"""
    cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
    sql = """
SELECT G.gene,T.ac,G.chr,G.strand,GE.start_i,GE.end_i
FROM transcript T
JOIN genomic_exon GE on T.ac=GE.ac
JOIN gene G ON T.gene=G.gene
WHERE T.ac=%(acv)s
ORDER BY T.ac,GE.start_i*G.strand
"""
    cur.execute( sql, {'acv': acv} )
    return cur.fetchall()





if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)

    conn = psycopg2.connect(database='reece')

    # acv = ACessions.Version (e.g., NM_0123.4)
    if len(sys.argv) > 1:
        # from command line
        acvs = sys.argv[1:]
        src = 'command line (%d accessions)' % len(acvs)
    else:
        # from database
        acvs = fetch_acvs(conn)
        acvs = acvs[:100]         # debugging
        src = 'database (%d accessions)' % len(acvs)

    acvs.sort()

    print( header(src) )

    for acv in acvs:
        try:
            g_info = fetch_gene_info_for_transcript(conn,acv)
            t_info = fetch_transcript_info(conn,acv)
            g_info['chromosome'] = g_info['chr']
            t_info['chromosome'] = t_info['chr']
            t_info['accession'] = t_info['ac']
            t_info['sequence'] = t_info['seq']

            if t_info is None:
                raise RuntimeError('transcript not found (not in cache?)')

            g_exons = fetch_genome_exon_coords(conn,acv)
            t_exons = fetch_transcript_exon_coords(conn,acv)

            g_ex_lens = [ e['end_i']-e['start_i'] for e in g_exons ]
            t_ex_lens = [ e['end_i']-e['start_i'] for e in t_exons ]

            exon_map = ltr.make_exon_mapping( g_exons, t_exons )

            mismatches = []
            if t_info['mismatches_p']:
                # align only if transcripts database says there are mismatches
                logging.info('aligning exons for '+acv)
                mismatches = ltr.build_exon_disrepancies( gene_info=g_info,
                                                          transcript_info=t_info,
                                                          exon_map=exon_map )

            subs = [ mm for mm in mismatches if mm.type == 'X' ]
            ins =  [ mm for mm in mismatches if mm.type == 'I' ]
            dels = [ mm for mm in mismatches if mm.type == 'D' ]

            print('* ' + '\t'.join([acv, g_info['gene'],
                                    strand_sign(g_info['strand']) + g_info['maploc'],
                                    str(len(t_exons)),                 # num transcript exons
                                    str(len(g_exons) == len(t_exons)), # num exons match
                                    str(g_ex_lens == t_ex_lens),       # exon lengths match
                                    str(len(mismatches)),              # num contiguous mismatches
                                    '%dX/%dI/%dD' % (len(subs),len(ins),len(dels)),
                                    ]))
            for mm in mismatches:
                print('\t'+'\t'.join([ mm.chr, 
                                       str(mm.g_start_i+1), str(mm.g_end_i),
                                       mm.hgvsc_pos,
                                       str(mm.exon+1), str(mm.e_start_i+1), str(mm.e_end_i),
                                       mm.type, mm.g_aseq, mm.t_aseq,
                                       mm.seqviewer_url,
                                       ]))

        except RuntimeError as e:
            print('#' + acv + ': ' + e.message)
            logging.warn(acv + ': ' + e.message)

