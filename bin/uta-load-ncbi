#!/usr/bin/env python

from __future__ import division, print_function, unicode_literals

__doc__ = """load NCBI genes and/or transcripts into UTA"""
__version__ = '1.0.0'

import os, sys
import filecache
import logging

import IPython
import sqlalchemy.exc
import sqlsoup

from locus.core.exceptions import LocusNCBIError
import locus.ncbi.gene
import locus.ncbi.refseq
import locus.ncbi.helpers as lnh


@filecache.filecache(filecache.MONTH)
def _fetch_gene(hgnc):
    """return raw XML for NCBI gene record, cached"""
    return lnh.efetch_gene_by_hgnc_name(hgnc)

@filecache.filecache(filecache.MONTH)
def _fetch_refseq(nm):
    """return raw XML for NCBI refseq record, cached"""
    return lnh.efetch_nuccore_by_ac(nm)

def _strand_as_signed_int(plus_minus):
    if plus_minus == 'plus': return 1
    if plus_minus == 'minus': return -1
    raise RuntimeError('strand "'+plus_minus+'" not understood')

def _load_gene(db,g):
    """load given locus.ncbi.gene.Gene"""
    m = g.grch37p10_mapping()
    db.gene.insert(
        gene = g.hgnc,
        chr = m['chr'], strand = _strand_as_signed_int(m['strand']),
        start_i = m['start_i'], end_i = m['end_i'], maploc = g.maploc,
        descr = g.desc, summary = g.summary
        )
    logging.info('gene %s: loaded' % g.hgnc)

def _load_transcript(db,t,g):
    """load given locus.ncbi.refseq.RefSeq"""
    g_exons = g.grch37p10_product_exons(t.acv)

    t_exons = t.exons
    t_ex_names = t.exon_names
    assert len(t_exons) == len(t_ex_names), nm+": exon <s,e> list and exon name list have different numbers of elements"

    # TBD: figure out how to defer constraints with sqlsoup/sqlalchemy
    # didn't work: db.connection().execute('SET CONSTRAINTS all DEFERRED')
    # (and appropriate constraints are marked deferrable)

    # load transcript
    cds_start_i,cds_end_i = t.cds_start_end_i
    db.transcript.insert( ac = nm, gene = g.hgnc, cds_start_i = cds_start_i,
                             cds_end_i = cds_end_i, seq = t.seq )

    # genomic exons
    for i,se in enumerate(g_exons):
        db.genomic_exon.insert(ac = nm, start_i = se[0], end_i = se[1], ord = i+1)

    # transcript exons
    for i,sen in enumerate(zip(t_exons,t_ex_names)):
        # sen = [[start,end],name]
        db.transcript_exon.insert(ac = nm,  name = sen[1], ord = i+1,
                                     start_i = sen[0][0], end_i = sen[0][1])

    return (len(g_exons), len(t_exons))


def load_gene_and_transcripts(db,hgnc):
    """load gene and all transcripts for it"""
    g =_fetch_gene(hgnc)
    _load_gene(db,g)

    products = g.grch37p10_products()
    nms = set([ p for p in products if p.startswith('NM_') ])
    if len(nms) == 0:
        logging.warn("Gene {gene} has no NMs ({np} total)".format(
                gene = hgnc, np = len(products)))

    for nm in nms:
        _load_transcript(db, _fetch_transcript(nm), g)

    logging.debug('loading Gene %s, %d tx: %s' % (hgnc, len(nms), ', '.join(sorted(nms)))) 
        
    
def load_transcript_and_gene(db,nm,g=None):
    """load transcript and, if needed, relevant gene"""
    t = locus.ncbi.refseq.RefSeq( _fetch_refseq(nm) )
    assert nm == t.acv, "asked for transcript %s, got %s" % (nm,t.acv)
    if len(t.gene) > 1:
        raise RuntimeError('%s is associated with %d genes (%s)' % (nm,len(t.gene),', '.join(t.gene)))
    if g is None:
        g = locus.ncbi.gene.Gene( _fetch_gene(t.gene[0]) )
    _load_gene(db, g)
    _load_transcript(db, t, g)
    return (t.acv, g.hgnc)


############################################################################

if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)

    # database schema defined in db.sql
    # 'postgresql:///' == local socket connection
    db = sqlsoup.SQLSoup('postgresql:///reece')
    conn = db.connection()

    for nm in sys.argv[1:]:
        trans = conn.begin()
        try:
            _,hgnc = load_transcript_and_gene(db,nm)
            trans.commit()
            logging.info( 'loaded transcript %s, gene %s' % (nm,hgnc) )
        except (AssertionError,LocusNCBIError,sqlalchemy.exc.SQLAlchemyError) as e:
            trans.rollback()
            logging.warn('Transcript %s: %s' % (nm,str(e)))
        
