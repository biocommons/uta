#!/usr/bin/env perl
#
# ensembl-fetch -- fetch fasta, txinfo, and seqinfo from ensembl
# You'll need to install the ensembl core api (at least) to use this
# code. You'll also need Log::Log4perl installed. 
#
# Tips: 
# 1) See http://uswest.ensembl.org/info/docs/api/api_git.html
# for ensembl api installation instructions.
# 2) sudo apt-get install liblog-log4perl-perl
#

use strict;
use warnings;

use Config::IniFiles;
use Data::Dumper;
use Getopt::Long qw(:config gnu_compat);
use IO::Compress::Gzip;
use IO::File;
use IO::Zlib;
use Log::Log4perl;

use Bio::EnsEMBL::ApiVersion;
use Bio::EnsEMBL::Registry;

use FindBin;

sub process1($);

############################################################################

my $root = "$FindBin::RealBin/..";

my $opts = {
    'database' => 'homo_sapiens_core_79_37',
    'host' => 'ensembldb.ensembl.org',
    'port' => 3337,		# 3337 is GRCh37; 5306 is GRCh38 (>=e76)
    'user' => 'anonymous',
    'pass' => undef,
};

our %nc_to_chr = (
    'NC_000001.10' =>  '1', 'NC_000002.11' =>  '2', 'NC_000003.11' => '3',
    'NC_000004.11' =>  '4', 'NC_000005.9'  =>  '5', 'NC_000006.11' => '6',
    'NC_000007.13' =>  '7', 'NC_000008.10' =>  '8', 'NC_000009.11' => '9',
    'NC_000010.10' => '10', 'NC_000011.9'  => '11', 'NC_000012.11' => '12',
    'NC_000013.10' => '13', 'NC_000014.8'  => '14', 'NC_000015.9'  => '15',
    'NC_000016.9'  => '16', 'NC_000017.10' => '17', 'NC_000018.9'  => '18',
    'NC_000019.9'  => '19', 'NC_000020.10' => '20', 'NC_000021.8'  => '21',
    'NC_000022.10' => '22', 'NC_000023.10' =>  'X', 'NC_000024.9'  => 'Y',
    );
our %chr_to_nc = map { $nc_to_chr{$_} => $_ } keys %nc_to_chr;

my $method = 'genebuild';
my $origin = 'ensembl';

my %accepted_biotypes = map {$_ => 1} qw(protein_coding pseudogene miRNA snRNA snoRNA);

############################################################################

Log::Log4perl->init_once( "$root/etc/logging.conf" );
our $logger = Log::Log4perl->get_logger();

GetOptions($opts,
	   'host|h=s',
	   'port|p=s',
	   'user|u=s',
	   'config|C=s',
    )
    || die("$0: you got usage issues, homey\n");

my $registry = 'Bio::EnsEMBL::Registry';
$registry->load_registry_from_db(
    -host => $opts->{host},
    -user => $opts->{user},
    -port => $opts->{port},
    -pass => $opts->{pass},
    );

#print("version check=", $registry->version_check(), "\n");

my $eversion = software_version();
$origin .= "-$eversion";

our $ga = $registry->get_adaptor( 'homo sapiens', 'core', 'gene' );
our $sa = $registry->get_adaptor( 'homo sapiens', 'core', 'slice' );
our $ta = $registry->get_adaptor( 'homo sapiens', 'core', 'transcript' );

our $tiw_fn = "ensembl-$eversion.txinfo.gz";
our $esw_fn = "ensembl-$eversion.exonset.gz";
our $faw_fn = "ensembl-$eversion.fasta.gz";

our $tiw = IO::Zlib->new("$tiw_fn.tmp", "wb");
our $esw = IO::Zlib->new("$esw_fn.tmp", "wb");
our $faw = IO::Zlib->new("$faw_fn.tmp", "wb");

$tiw->print( join("\t",qw(origin ac hgnc cds_se_i exons_se_i)), "\n" );
$esw->print( join("\t",qw(tx_ac alt_ac method strand exons_se_i)), "\n" );

if (@ARGV) {
    for(my $i=0; $i<=$#ARGV; $i++) {
	my $hgnc = $ARGV[$i];
	chomp($hgnc);
	my @GENEs = @{ $ga->fetch_all_by_external_name($hgnc) };
	if ($#GENEs == -1) {
	    $logger->error("gene $hgnc is not in Ensembl");
	    next;
	}
	if ($#GENEs >= 1) {
	    $logger->warn(sprintf("gene $hgnc: got %d replies (processing all)",
			  $#GENEs+1));
	}
	$logger->info(sprintf("%d/%d (%.1f%%): gene %s\n",
			      ($i+1), ($#ARGV+1), ($i+1)/($#ARGV+1)*100, $hgnc));
	foreach my $g (@GENEs) {
	    if ($hgnc ne $g->external_name()) {
		$logger->warn(sprintf("Requested gene %s; got reply for %s",
				      $hgnc, $g->external_name()));
	    }
	    process1($g);
	}
    }
} else {
    my @GENEs = @{ $ga->fetch_all() };
    for(my $i=0; $i<=$#GENEs; $i++) {
	my $g = $GENEs[$i];
	my $hgnc = $g->external_name();
	$logger->info(sprintf("%d/%d (%.1f%%): gene %s\n",
			      ($i+1), ($#GENEs+1), ($i+1)/($#GENEs+1)*100, $hgnc));
	process1($g);
    }
}

$tiw->close();
$esw->close();
$faw->close();

rename("$tiw_fn.tmp",$tiw_fn);
rename("$esw_fn.tmp",$esw_fn);
rename("$faw_fn.tmp",$faw_fn);

exit(0);

our %tx_seen;
sub process1($) {
    my ($g) = @_;
    my $hgnc = $g->external_name();

    my @tx = @{ $g->get_all_Transcripts };
    $logger->info(sprintf("%d transcripts for gene %s\n",$#tx+1,$hgnc));

    foreach my $tx (@tx) {
	if (exists $tx_seen{$tx->display_id}) {
	    my @others = sort(@{$tx_seen{$tx->display_id}});
	    $logger->warn(sprintf("gene %s: %s already seen for %d genes (%s); skipping",
				  $hgnc, $tx->display_id, $#others+1, join(",",@others)));
	    push(@{$tx_seen{$tx->display_id}},$hgnc);
	    next;
	}
	push(@{$tx_seen{$tx->display_id}},$hgnc);

	if (not exists $accepted_biotypes{$tx->biotype}) {
	    $logger->info(sprintf("%s: is type %s; skipping",$tx->display_id,$tx->biotype));
	    next;
	}

	my $hgnc = $tx->get_Gene()->external_name();
	my $tx_c = @{$tx->project('chromosome')}[0];
	if (not defined $tx_c) {
	    $logger->error(sprintf("Can't project %s onto a chromosome; skipping",$tx->display_id));
	    next;
	}
	my $srn = $tx_c->to_Slice()->seq_region_name;
	if (not exists $chr_to_nc{$srn}) {
	    $logger->warn(sprintf("gene %s, tx %s (%s): on %s, no NC available; skipping",
				  $hgnc, $tx->display_id(), $g->biotype(), $srn));
	    next;
	}
	my $nc = $chr_to_nc{$srn};
	my $seq = $tx->seq->seq;

	$logger->info(sprintf("%s (%s; %s); %d nt\n",$tx->display_id,$hgnc,$tx->strand,length($seq)));

	# write sequence and seqinfo
	$faw->print(">",$tx->display_id,"\n",$seq,"\n");

	# write exonset
	my @g_exons = @{ $tx->get_all_Exons() };
	my $g_exons_str = join(';', map( sprintf("%d,%d",$_->start()-1,$_->end()), @g_exons ));
	$esw->print( join("\t", $tx->display_id(), $nc, $method, $tx->strand(), $g_exons_str), "\n");

	# write txinfo
	my $tm = $tx->get_TranscriptMapper();
	my @c_exon_coords = map( $tm->genomic2cdna($_->start(),$_->end(),$tx->strand), @g_exons );
	my $c_exon_str = join(';', map( sprintf("%d,%d",$_->start()-1,$_->end()), @c_exon_coords ));
	my $cds_se_i = '';
	if ($tx->biotype eq 'protein_coding') {
	    $cds_se_i = sprintf("%d,%d",$tx->cdna_coding_start-1,$tx->cdna_coding_end);
	}
	$tiw->print(join("\t", $origin, $tx->display_id(), $hgnc, $cds_se_i, $c_exon_str),"\n");
    }
}


## <LICENSE>
## Copyright 2014 UTA Contributors (https://bitbucket.org/biocommons/uta)
## 
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
## 
##     http://www.apache.org/licenses/LICENSE-2.0
## 
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
## </LICENSE>
