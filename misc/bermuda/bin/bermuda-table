#!/usr/bin/env python

from __future__ import print_function

import logging
import re
import sys

import psycopg2
import psycopg2.extras

import recordtype

dsn = "host=localhost dbname=uta_dev"


############################################################################

cigarop_re = re.compile('(?P<count>\d+)(?P<op>[=XDI])')

class Tx(recordtype.recordtype('Tx',
                               ['ac','cds_start_i','cds_end_i'])):
    pass


class CIGAROp(recordtype.recordtype('CIGAROp',
                                    ['tx','exon','exon_start_i','op','count','r_start_i'])):
    @property
    def src_len(self):
        return 0 if self.op == 'I' else self.count

    @property
    def tgt_len(self):
        return 0 if self.op == 'D' else self.count

    @property
    def r_end_i(self):
        return self.r_start_i + self.src_len

    @property
    def c_start_i(self):
        return self.r_start_i - self.tx.cds_start_i

    @property
    def c_end_i(self):
        return self.r_end_i - self.tx.cds_start_i

    @property
    def in_cds(self):
        return self.r_start_i<=self.tx.cds_end_i and self.r_end_i>=self.tx.cds_start_i

    def as_string(self):
        c_start = self.c_start_i + 1
        c_end = self.c_end_i
        c_pos = str(c_start) if c_start == c_end else "{c_start}_{c_end}".format(c_start=c_start,c_end=c_end)
        return "{self.exon}:{self.count}{self.op}(c.{c_pos})".format(
            self = self,
            c_pos = c_pos
            )


def cigar_to_ops(tx,cigars):
    """for a list of cigar ops, return a list of CIGAROp objects"""
    ops = []
    r_pos = 0
    for i,cigar in enumerate(cigars):
        exon_pos = 0
        for op_d in [ op_m.groupdict() for op_m in cigarop_re.finditer(cigar)]:
            op = CIGAROp(
                tx = tx,
                exon = i+1,
                exon_start_i = exon_pos,
                op = op_d['op'],
                count = int(op_d['count']),
                r_start_i = r_pos,
                )
            r_pos += op.src_len
            exon_pos += op.src_len
            ops.append(op)
    return ops


############################################################################

def build_sel_sql(preds=[]):
    sel_preds = [ 
        ]
    sel_preds += preds
    query = ' '.join([
            'SELECT * FROM bermuda2.bermuda_data_mv',
            '' if len(sel_preds) == 0 else 'WHERE ' + ' AND '.join(sel_preds),
            'ORDER BY hgnc,tx_ac',
            ])
    return query

def row_str(row):
    notes = []
    warnings = []

    tx = Tx(row['tx_ac'], row['cds_start_i'], row['cds_end_i'])

    ops = [] if row['s_cigars'] is None else cigar_to_ops(tx,row['s_cigars'].split(';'))

    subs =       [ o for o in ops    if     o.op == 'X'  ]
    indels =     [ o for o in ops    if     o.op in 'DI' ]
    cds_indels = [ o for o in indels if     o.in_cds ]
    utr_indels = [ o for o in indels if not o.in_cds ]

    # alignment quality
    sb = (row['s_se_i'] is not None, row['b_se_i'] is not None)
    if row['s_status'] is None:
        alignment_quality = 'poor'
        warnings += ['avoid -- no splign alignment']
    elif 'n' in row['s_status']:
        alignment_quality = 'poor'
        warnings += ['avoid -- exon # mismatch']
    elif sb == (True,True):
        if row['s_se_i'] == row['b_se_i']:
            alignment_quality = 'high'
            notes += [ 'splign and blat coordinates agree precisely' ]
        else:
            alignment_quality = 'intermediate'
            warnings += [ 'splign and blat coordinates differ' ]
    elif sb == (True,False):
        alignment_quality = 'intermediate'
        warnings += [ 'not aligned by blat' ]
    elif sb == (False,True):
        alignment_quality = 'intermediate'
        warnings += [ 'not aligned by splign' ]
    else:
        alignment_quality = 'poor'
        warnings += [ 'no alignments available' ]

    # splign_refagree
    if row['s_status'] == 'NLxdi':
        splign_refagree = 'exact'
    elif row['s_minor']:
        edits = []
        if 'X' in row['s_status']:
            edits += [ 'sub' ]
        if 'D' in row['s_status']:
            edits += [ 'del' ]
        if 'I' in row['s_status']:
            edits += [ 'ins' ]
        splign_refagree = 'minor ('+','.join(edits)+')'
    else:
        splign_refagree = 'poor'

    # ensembl equivalents
    enst_equivs = 'no'
    if row['enst_equivs'] is not None:
        if '/CE' in row['enst_equivs']:
            return 'yes, CDS+UTR'
        elif '/CC' in enst_equivs:
            return 'yes, CDS only'

    return( '\t'.join([
                row['hgnc'],
                row['tx_ac'],
                format("{pm}{row[alt_ac]}:{row[alt_bounds]}".format(
                    row = row, pm = '+' if row['alt_strand'] == 1 else '-')),

                alignment_quality,
                splign_refagree,
                enst_equivs,
                'yes' if row['is_hgmd_tx'] else 'no',

                ','.join([op.as_string() for op in cds_indels]),
                ','.join([op.as_string() for op in utr_indels]),
                ','.join([op.as_string() for op in subs]),
                row['patches'] or '',
                row['enst_equivs'] or '',

                '; '.join(warnings),
                '; '.join(notes),
                ]))

############################################################################

if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)
    logger = logging.getLogger(__name__)

    con = psycopg2.connect(dsn)

    print( '\t'.join([
        "Gene (HGNC)",
        "Accession",
        "GRCh37 coordinates",
        "Alignment Quality",
        "Reference Agreement",
        "has Ensembl equivalents?",
        "is HGMD transcript?",
        "CDS indels",
        "UTR indels",
        "Substitutions",
        "Patch Alignments",
        "Ensembl Equivalents",
        "Warnings",
        "Notes",                    
        ]))
    # add ensembl verison, hgmd version

    sel_cur = con.cursor(cursor_factory=psycopg2.extras.DictCursor)

    if len(sys.argv) > 1:
        sel_sql = build_sel_sql(preds = [ 'hgnc = %(hgnc)s' ])
        print(sel_sql)
        for hgnc in sys.argv[1:]:
            sel_cur.execute(sel_sql,{'hgnc': hgnc})
            for row in sel_cur:
                print( row_str(row) )
    else:
        sel_sql = build_sel_sql() #preds=["tx_ac = 'NM_144670.4'"])
        sel_cur.execute(sel_sql)
        for row in sel_cur:
            print( row_str(row) )



## <LICENSE>
## Copyright 2014 UTA Contributors (https://bitbucket.org/invitae/uta)
## 
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
## 
##     http://www.apache.org/licenses/LICENSE-2.0
## 
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
## </LICENSE>
